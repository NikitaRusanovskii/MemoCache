# Документация для TTL-кэшей

## Обзор

Данный файл содержит две реализации кэшей с Time-To-Live (TTL): `LazyTTLCache` и `ImmediateTTLCache`. Оба класса наследуются от `BaseCache` и предоставляют механизм автоматического удаления элементов по истечении заданного времени жизни.

## Класс LazyTTLCache

### Описание
"Ленивый" TTL-кэш, который удаляет просроченные элементы только при выполнении операций (get/put). Не использует фоновые потоки для очистки.

### Конструктор
```cpp
LazyTTLCache(size_t capacity, std::chrono::duration<double> life_time)
```
**Параметры:**
- `capacity` - максимальная вместимость кэша
- `life_time` - время жизни элементов в кэше

**Исключения:**
- `std::runtime_error` - если capacity равен 0

### Методы

#### get
```cpp
Tvalue& get(const Tkey& key) override
```
Получает элемент по ключу. Если элемент просрочен, удаляет его и генерирует исключение.

**Исключения:**
- `std::runtime_error` - если ключ не найден или элемент просрочен

#### put
```cpp
void put(const Tkey& key, const Tvalue& item) override
```
Добавляет элемент в кэш. Перед добавлением пытается освободить место путем удаления просроченных элементов.

**Исключения:**
- `std::runtime_error` - если кэш заполнен и невозможно освободить место

#### contains
```cpp
bool contains(const Tkey& key) override
```
Проверяет наличие ключа в кэше (без проверки на просроченность).

#### erase
```cpp
void erase(const Tkey& key) override
```
Удаляет элемент по ключу.

**Исключения:**
- `std::runtime_error` - если ключ не найден

#### clear
```cpp
void clear() override
```
Полностью очищает кэш.

#### size
```cpp
size_t size() const
```
Возвращает текущее количество элементов в кэше.

### Внутренние методы

#### make_room
```cpp
bool make_room()
```
Удаляет все просроченные элементы. Возвращает true, если были удалены какие-либо элементы.

## Класс ImmediateTTLCache

### Описание
"Активный" TTL-кэш, который использует фоновый поток для регулярной очистки просроченных элементов. Удаление происходит каждые 100ms.

### Конструктор и деструктор
```cpp
ImmediateTTLCache(size_t capacity, std::chrono::duration<double> life_time)
```
Создает кэш и запускает фоновый поток для очистки.

```cpp
~ImmediateTTLCache()
```
Останавливает фоновый поток и дожидается его завершения.

### Методы

Методы имеют ту же сигнатуру и функциональность, что и в `LazyTTLCache`, за исключением:

- `put` - не пытается очистить место перед добавлением, полагается на фоновую очистку
- Все методы потокобезопасны благодаря использованию мьютекса

### Внутренние методы

#### background_cleaner
```cpp
void background_cleaner()
```
Фоновая задача, которая выполняется в отдельном потоке и периодически удаляет просроченные элементы.

## Общие характеристики

### Структура данных
- `std::unordered_map<Tkey, Tvalue> storage` - основное хранилище (унаследовано от BaseCache)
- `std::unordered_map<Tkey, std::chrono::time_point<clock>> key_time` - время добавления каждого элемента
- `std::mutex mtx` - для обеспечения потокобезопасности

### Используемые типы
- `using clock = std::chrono::steady_clock` - монотонные часы для измерения времени

### Потокобезопасность
- Оба класса полностью потокобезопасны
- Используется `std::lock_guard` для синхронизации доступа
- `ImmediateTTLCache` дополнительно синхронизирует фоновую очистку

### Особенности реализации

#### LazyTTLCache
- **Плюсы:** Простая реализация, нет накладных расходов на фоновые потоки
- **Минусы:** Просроченные элементы могут оставаться в кэше до следующей операции

#### ImmediateTTLCache
- **Плюсы:** Гарантированное своевременное удаление просроченных элементов
- **Минусы:** Дополнительные накладные расходы на фоновый поток

## Пример использования

```cpp
// Ленивый TTL-кэш на 100 элементов с временем жизни 5 минут
LazyTTLCache<int, std::string> lazy_cache(100, std::chrono::minutes(5));

// Активный TTL-кэш на 50 элементов с временем жизни 1 час
ImmediateTTLCache<std::string, Data> immediate_cache(50, std::chrono::hours(1));

// Добавление элементов
lazy_cache.put(1, "value1");
immediate_cache.put("key1", data_object);

// Получение элементов
try {
    auto& value = lazy_cache.get(1);
    auto& data = immediate_cache.get("key1");
} catch (const std::runtime_error& e) {
    // Обработка случая, когда элемент не найден или просрочен
}
```

## Примечания по производительности

- `LazyTTLCache`: операции put могут быть медленными при большом количестве просроченных элементов
- `ImmediateTTLCache`: постоянные накладные расходы на фоновый поток, но операции put/get быстрее
- Оба класса обеспечивают потокобезопасность с помощью мьютексов, что может стать узким местом при высокой конкуренции

## Рекомендации по использованию

- Используйте `LazyTTLCache` когда нагрузка неравномерна и можно допустить временное наличие просроченных элементов
- Используйте `ImmediateTTLCache` когда важно гарантировать своевременное удаление просроченных данных
- Учитывайте накладные расходы на синхронизацию в многопоточных сценариях